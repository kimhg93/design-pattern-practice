package com.practice.design_pattern.state;

/**
 *
 * 객체가 상태에 따라 다른 동작을 수행해야 하거나, 많은 조건문으로 분기처리를 해야할 때 사용한다.
 * 상태를 객체화 하여 각 상태에 따른 동작을 상태 클래스로 구현한다.
 *
 * 가독성과 유지보수성 향상: 객체의 동작을 상태에 따라 캡슐화하여 코드를 구조화한다. 각 상태를 별도의 클래스로 정의하고 상태별 동작을 구현하므로 코드의 가독성이 향상되고,
 *  상태 변화에 따른 동작을 쉽게 이해할 수 있다. 또한, 상태를 변경하거나 추가하는 경우 해당 상태 클래스만 수정하면 되므로 유지보수성이 향상된다.
 * 코드 중복 제거 :각 상태를 별도의 클래스로 분리하고 상태별 동작을 구현하기 때문에 조건문을 사용하지 않고 코드 중복을 제거할 수 있다.
 *  확장성과 유연성 : 상태를 추가하거나 변경하려면 해당 상태의 클래스만 수정하면 된다. 존 코드에 영향을 최소화하면서 변경을 용이하게 한다. 상태 객체를 교체하여 동작을 동적으로 변경할 수 있다.
 * 객체간 상태 공유 :상태 클래스는 독립적인 객체로서 여러 개의 컨텍스트 객체에서 공유될 수 있으며, 각 컨텍스트 객체는 동일한 상태 객체를 사용하여 동작을 수행할 수 있습니다.
 * 단일 책임 원칙 : 상태는 독립적인 객체로서 특정 상태에 따른 동작을 캡슐화하고, 컨텍스트 객체는 현재 상태에 따라 해당 상태 객체의 메서드를 호출하는 역할을 수행.
 *  이로 인해 클래스의 역할과 책임이 분리되어 코드의 구조가 단순화되고 유지보수가 용이하다.
 *
 */
public class Main {

    public static void main(String[] args) {
        Jindo jindo = new Jindo();
        jindo.printState();
        System.out.println("=====================");
        jindo.order();
        jindo.callName();
        jindo.printState();
        System.out.println("=====================");
        jindo.order();
        jindo.callName();
        jindo.printState();

    }
}
