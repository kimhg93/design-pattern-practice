package com.practice.design_pattern.template_method;

/**
 * 상위 수준의 알고리즘을 추상 클래스에 정의하고, 알고리즘의 일부 단계를 서브클래스에서 구현하도록 한다.
 * 이렇게 함으로써 알고리즘의 구조를 유지하면서, 특정 단계의 구현을 서브클래스에서 다르게 할 수 있다.
 *
 * 알고리즘의 일관된 구조를 유지하면서도 서브클래스마다 다른 동작을 가능하게 합니다.
 * 코드 중복을 방지하고 재사용성을 향상시킬 수 있다. 다양한 클래스에서 동일한 알고리즘을 사용해야 하는 경우 유용
 * 알고리즘의 구조를 수정하거나 세부 단계를 변경하는 데 용이.
 * 상속을 기반으로 하기 때문에 다형성을 활용할 수 있다. 추상 클래스에서 정의된 템플릿 메소드를 구체 클래스에서 오버라이딩하여 다양한 동작을 수행할 수 있다.
 *
 * 코드 중복 제거 : 알고리즘의 공통 부분을 추상 클래스에 구현하므로 구현체에서 중복 코드를 작성할 필요가 없다.
 * 확장성 : 구현체에서 일부 단계를 구현함으로써, 알고리즘을 추가하거나 기존 알고리즘을 수정할 필요 없이 구현체를 작성하여 알고리즘을 확장할 수 있다.
 * 일관성 : 알고리즘의 구조가 추상 클래스에 의해 정의되므로, 모든 구현체에서 동일한 알고리즘 구조를 따른다.
 * 유연한 수정 : 알고리즘의 구조를 수정하거나 세부 단계를 변경하려면 추상 클래스만 수정하면 된다.
 */

public class Main {

    public static void main(String[] args) {
	    WalkPet walkDog = new WalkDog();
        walkDog.walkAnimal();

        System.out.println("===============================");

        WalkPet walkCat = new WalkCat();
        walkCat.walkAnimal();
    }
}
